// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: base.proto

package types

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Specifies the int64 start and end of the range using half-open interval semantics [start, end).
type Int64Range struct {
	// start of the range (inclusive)
	Start int64 `protobuf:"varint,1,opt,name=start,proto3" json:"start,omitempty"`
	// end of the range (exclusive)
	End int64 `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
	// If specified, the match result will be inverted before checking. Defaults to false.
	InvertMatch          bool     `protobuf:"varint,3,opt,name=invert_match,json=invertMatch,proto3" json:"invert_match,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Int64Range) Reset()         { *m = Int64Range{} }
func (m *Int64Range) String() string { return proto.CompactTextString(m) }
func (*Int64Range) ProtoMessage()    {}
func (*Int64Range) Descriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{0}
}
func (m *Int64Range) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Int64Range) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Int64Range.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Int64Range) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Int64Range.Merge(m, src)
}
func (m *Int64Range) XXX_Size() int {
	return m.Size()
}
func (m *Int64Range) XXX_DiscardUnknown() {
	xxx_messageInfo_Int64Range.DiscardUnknown(m)
}

var xxx_messageInfo_Int64Range proto.InternalMessageInfo

func (m *Int64Range) GetStart() int64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *Int64Range) GetEnd() int64 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *Int64Range) GetInvertMatch() bool {
	if m != nil {
		return m.InvertMatch
	}
	return false
}

// CidrRange specifies an IP Address and a prefix length to construct
// the subnet mask for a `CIDR <https://tools.ietf.org/html/rfc4632>`_ range.
type CidrRange struct {
	// IPv4 or IPv6 address, e.g. ``192.0.0.0`` or ``2001:db8::``.
	AddressPrefix string `protobuf:"bytes,1,opt,name=address_prefix,json=addressPrefix,proto3" json:"address_prefix,omitempty"`
	// Length of prefix, e.g. 0, 32.
	PrefixLen int32 `protobuf:"varint,2,opt,name=prefix_len,json=prefixLen,proto3" json:"prefix_len,omitempty"`
	// If specified, the match result will be inverted before checking. Defaults to false.
	InvertMatch          bool     `protobuf:"varint,3,opt,name=invert_match,json=invertMatch,proto3" json:"invert_match,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CidrRange) Reset()         { *m = CidrRange{} }
func (m *CidrRange) String() string { return proto.CompactTextString(m) }
func (*CidrRange) ProtoMessage()    {}
func (*CidrRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{1}
}
func (m *CidrRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CidrRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CidrRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CidrRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CidrRange.Merge(m, src)
}
func (m *CidrRange) XXX_Size() int {
	return m.Size()
}
func (m *CidrRange) XXX_DiscardUnknown() {
	xxx_messageInfo_CidrRange.DiscardUnknown(m)
}

var xxx_messageInfo_CidrRange proto.InternalMessageInfo

func (m *CidrRange) GetAddressPrefix() string {
	if m != nil {
		return m.AddressPrefix
	}
	return ""
}

func (m *CidrRange) GetPrefixLen() int32 {
	if m != nil {
		return m.PrefixLen
	}
	return 0
}

func (m *CidrRange) GetInvertMatch() bool {
	if m != nil {
		return m.InvertMatch
	}
	return false
}

type StringMatcherConf struct {
	// Types that are valid to be assigned to MatchPattern:
	//	*StringMatcherConf_ExactMatch
	//	*StringMatcherConf_PrefixMatch
	//	*StringMatcherConf_SuffixMatch
	//	*StringMatcherConf_RegexMatch
	MatchPattern isStringMatcherConf_MatchPattern `protobuf_oneof:"match_pattern"`
	// If specified, the match result will be inverted before checking. Defaults to false.
	InvertMatch          bool     `protobuf:"varint,5,opt,name=invert_match,json=invertMatch,proto3" json:"invert_match,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StringMatcherConf) Reset()         { *m = StringMatcherConf{} }
func (m *StringMatcherConf) String() string { return proto.CompactTextString(m) }
func (*StringMatcherConf) ProtoMessage()    {}
func (*StringMatcherConf) Descriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{2}
}
func (m *StringMatcherConf) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StringMatcherConf) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StringMatcherConf.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StringMatcherConf) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StringMatcherConf.Merge(m, src)
}
func (m *StringMatcherConf) XXX_Size() int {
	return m.Size()
}
func (m *StringMatcherConf) XXX_DiscardUnknown() {
	xxx_messageInfo_StringMatcherConf.DiscardUnknown(m)
}

var xxx_messageInfo_StringMatcherConf proto.InternalMessageInfo

type isStringMatcherConf_MatchPattern interface {
	isStringMatcherConf_MatchPattern()
	MarshalTo([]byte) (int, error)
	Size() int
}

type StringMatcherConf_ExactMatch struct {
	ExactMatch string `protobuf:"bytes,1,opt,name=exact_match,json=exactMatch,proto3,oneof" json:"exact_match,omitempty"`
}
type StringMatcherConf_PrefixMatch struct {
	PrefixMatch string `protobuf:"bytes,2,opt,name=prefix_match,json=prefixMatch,proto3,oneof" json:"prefix_match,omitempty"`
}
type StringMatcherConf_SuffixMatch struct {
	SuffixMatch string `protobuf:"bytes,3,opt,name=suffix_match,json=suffixMatch,proto3,oneof" json:"suffix_match,omitempty"`
}
type StringMatcherConf_RegexMatch struct {
	RegexMatch string `protobuf:"bytes,4,opt,name=regex_match,json=regexMatch,proto3,oneof" json:"regex_match,omitempty"`
}

func (*StringMatcherConf_ExactMatch) isStringMatcherConf_MatchPattern()  {}
func (*StringMatcherConf_PrefixMatch) isStringMatcherConf_MatchPattern() {}
func (*StringMatcherConf_SuffixMatch) isStringMatcherConf_MatchPattern() {}
func (*StringMatcherConf_RegexMatch) isStringMatcherConf_MatchPattern()  {}

func (m *StringMatcherConf) GetMatchPattern() isStringMatcherConf_MatchPattern {
	if m != nil {
		return m.MatchPattern
	}
	return nil
}

func (m *StringMatcherConf) GetExactMatch() string {
	if x, ok := m.GetMatchPattern().(*StringMatcherConf_ExactMatch); ok {
		return x.ExactMatch
	}
	return ""
}

func (m *StringMatcherConf) GetPrefixMatch() string {
	if x, ok := m.GetMatchPattern().(*StringMatcherConf_PrefixMatch); ok {
		return x.PrefixMatch
	}
	return ""
}

func (m *StringMatcherConf) GetSuffixMatch() string {
	if x, ok := m.GetMatchPattern().(*StringMatcherConf_SuffixMatch); ok {
		return x.SuffixMatch
	}
	return ""
}

func (m *StringMatcherConf) GetRegexMatch() string {
	if x, ok := m.GetMatchPattern().(*StringMatcherConf_RegexMatch); ok {
		return x.RegexMatch
	}
	return ""
}

func (m *StringMatcherConf) GetInvertMatch() bool {
	if m != nil {
		return m.InvertMatch
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*StringMatcherConf) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*StringMatcherConf_ExactMatch)(nil),
		(*StringMatcherConf_PrefixMatch)(nil),
		(*StringMatcherConf_SuffixMatch)(nil),
		(*StringMatcherConf_RegexMatch)(nil),
	}
}

type HeaderMatcherConf struct {
	// Specifies the name of the header in the request.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Specifies how the header match will be performed to route the request.
	//
	// Types that are valid to be assigned to HeaderMatchSpecifier:
	//	*HeaderMatcherConf_ExactMatch
	//	*HeaderMatcherConf_RegexMatch
	//	*HeaderMatcherConf_RangeMatch
	//	*HeaderMatcherConf_PresentMatch
	//	*HeaderMatcherConf_PrefixMatch
	//	*HeaderMatcherConf_SuffixMatch
	HeaderMatchSpecifier isHeaderMatcherConf_HeaderMatchSpecifier `protobuf_oneof:"header_match_specifier"`
	// If specified, the match result will be inverted before checking. Defaults to false.
	//
	// Examples:
	//
	// * The regex *\d{3}* does not match the value *1234*, so it will match when inverted.
	// * The range [-10,0) will match the value -1, so it will not match when inverted.
	InvertMatch          bool     `protobuf:"varint,8,opt,name=invert_match,json=invertMatch,proto3" json:"invert_match,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HeaderMatcherConf) Reset()         { *m = HeaderMatcherConf{} }
func (m *HeaderMatcherConf) String() string { return proto.CompactTextString(m) }
func (*HeaderMatcherConf) ProtoMessage()    {}
func (*HeaderMatcherConf) Descriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{3}
}
func (m *HeaderMatcherConf) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeaderMatcherConf) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HeaderMatcherConf.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HeaderMatcherConf) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeaderMatcherConf.Merge(m, src)
}
func (m *HeaderMatcherConf) XXX_Size() int {
	return m.Size()
}
func (m *HeaderMatcherConf) XXX_DiscardUnknown() {
	xxx_messageInfo_HeaderMatcherConf.DiscardUnknown(m)
}

var xxx_messageInfo_HeaderMatcherConf proto.InternalMessageInfo

type isHeaderMatcherConf_HeaderMatchSpecifier interface {
	isHeaderMatcherConf_HeaderMatchSpecifier()
	MarshalTo([]byte) (int, error)
	Size() int
}

type HeaderMatcherConf_ExactMatch struct {
	ExactMatch string `protobuf:"bytes,2,opt,name=exact_match,json=exactMatch,proto3,oneof" json:"exact_match,omitempty"`
}
type HeaderMatcherConf_RegexMatch struct {
	RegexMatch string `protobuf:"bytes,3,opt,name=regex_match,json=regexMatch,proto3,oneof" json:"regex_match,omitempty"`
}
type HeaderMatcherConf_RangeMatch struct {
	RangeMatch *Int64Range `protobuf:"bytes,4,opt,name=range_match,json=rangeMatch,proto3,oneof" json:"range_match,omitempty"`
}
type HeaderMatcherConf_PresentMatch struct {
	PresentMatch bool `protobuf:"varint,5,opt,name=present_match,json=presentMatch,proto3,oneof" json:"present_match,omitempty"`
}
type HeaderMatcherConf_PrefixMatch struct {
	PrefixMatch string `protobuf:"bytes,6,opt,name=prefix_match,json=prefixMatch,proto3,oneof" json:"prefix_match,omitempty"`
}
type HeaderMatcherConf_SuffixMatch struct {
	SuffixMatch string `protobuf:"bytes,7,opt,name=suffix_match,json=suffixMatch,proto3,oneof" json:"suffix_match,omitempty"`
}

func (*HeaderMatcherConf_ExactMatch) isHeaderMatcherConf_HeaderMatchSpecifier()   {}
func (*HeaderMatcherConf_RegexMatch) isHeaderMatcherConf_HeaderMatchSpecifier()   {}
func (*HeaderMatcherConf_RangeMatch) isHeaderMatcherConf_HeaderMatchSpecifier()   {}
func (*HeaderMatcherConf_PresentMatch) isHeaderMatcherConf_HeaderMatchSpecifier() {}
func (*HeaderMatcherConf_PrefixMatch) isHeaderMatcherConf_HeaderMatchSpecifier()  {}
func (*HeaderMatcherConf_SuffixMatch) isHeaderMatcherConf_HeaderMatchSpecifier()  {}

func (m *HeaderMatcherConf) GetHeaderMatchSpecifier() isHeaderMatcherConf_HeaderMatchSpecifier {
	if m != nil {
		return m.HeaderMatchSpecifier
	}
	return nil
}

func (m *HeaderMatcherConf) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HeaderMatcherConf) GetExactMatch() string {
	if x, ok := m.GetHeaderMatchSpecifier().(*HeaderMatcherConf_ExactMatch); ok {
		return x.ExactMatch
	}
	return ""
}

func (m *HeaderMatcherConf) GetRegexMatch() string {
	if x, ok := m.GetHeaderMatchSpecifier().(*HeaderMatcherConf_RegexMatch); ok {
		return x.RegexMatch
	}
	return ""
}

func (m *HeaderMatcherConf) GetRangeMatch() *Int64Range {
	if x, ok := m.GetHeaderMatchSpecifier().(*HeaderMatcherConf_RangeMatch); ok {
		return x.RangeMatch
	}
	return nil
}

func (m *HeaderMatcherConf) GetPresentMatch() bool {
	if x, ok := m.GetHeaderMatchSpecifier().(*HeaderMatcherConf_PresentMatch); ok {
		return x.PresentMatch
	}
	return false
}

func (m *HeaderMatcherConf) GetPrefixMatch() string {
	if x, ok := m.GetHeaderMatchSpecifier().(*HeaderMatcherConf_PrefixMatch); ok {
		return x.PrefixMatch
	}
	return ""
}

func (m *HeaderMatcherConf) GetSuffixMatch() string {
	if x, ok := m.GetHeaderMatchSpecifier().(*HeaderMatcherConf_SuffixMatch); ok {
		return x.SuffixMatch
	}
	return ""
}

func (m *HeaderMatcherConf) GetInvertMatch() bool {
	if m != nil {
		return m.InvertMatch
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*HeaderMatcherConf) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*HeaderMatcherConf_ExactMatch)(nil),
		(*HeaderMatcherConf_RegexMatch)(nil),
		(*HeaderMatcherConf_RangeMatch)(nil),
		(*HeaderMatcherConf_PresentMatch)(nil),
		(*HeaderMatcherConf_PrefixMatch)(nil),
		(*HeaderMatcherConf_SuffixMatch)(nil),
	}
}

func init() {
	proto.RegisterType((*Int64Range)(nil), "meshapi.security.rbac.v1.Int64Range")
	proto.RegisterType((*CidrRange)(nil), "meshapi.security.rbac.v1.CidrRange")
	proto.RegisterType((*StringMatcherConf)(nil), "meshapi.security.rbac.v1.StringMatcherConf")
	proto.RegisterType((*HeaderMatcherConf)(nil), "meshapi.security.rbac.v1.HeaderMatcherConf")
}

func init() { proto.RegisterFile("base.proto", fileDescriptor_db1b6b0986796150) }

var fileDescriptor_db1b6b0986796150 = []byte{
	// 418 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x93, 0xcf, 0x8e, 0xd3, 0x30,
	0x10, 0xc6, 0x9b, 0x64, 0xb3, 0x6c, 0x27, 0x2d, 0xb0, 0x16, 0x82, 0x5c, 0x88, 0xb6, 0x85, 0x95,
	0xf6, 0x14, 0x89, 0x3f, 0xe2, 0x01, 0x76, 0x0f, 0x14, 0x09, 0x24, 0x14, 0x0e, 0x48, 0x5c, 0x22,
	0x37, 0x99, 0xb4, 0x96, 0xa8, 0x1b, 0x8d, 0xdd, 0xaa, 0x7d, 0x13, 0x1e, 0x89, 0x23, 0x37, 0xae,
	0xa8, 0xf0, 0x20, 0x28, 0x76, 0x42, 0xff, 0x05, 0xa9, 0x37, 0xfb, 0xe7, 0x2f, 0xf3, 0xf9, 0x9b,
	0x71, 0x00, 0xc6, 0x5c, 0x61, 0x5c, 0xd2, 0x5c, 0xcf, 0x59, 0x38, 0x43, 0x35, 0xe5, 0xa5, 0x88,
	0x15, 0x66, 0x0b, 0x12, 0x7a, 0x1d, 0xd3, 0x98, 0x67, 0xf1, 0xf2, 0xc5, 0xf0, 0x33, 0xc0, 0x3b,
	0xa9, 0xdf, 0xbc, 0x4e, 0xb8, 0x9c, 0x20, 0x7b, 0x04, 0xbe, 0xd2, 0x9c, 0x74, 0xe8, 0x5c, 0x39,
	0x37, 0x5e, 0x62, 0x37, 0xec, 0x21, 0x78, 0x28, 0xf3, 0xd0, 0x35, 0xac, 0x5a, 0xb2, 0x01, 0xf4,
	0x84, 0x5c, 0x22, 0xe9, 0x74, 0xc6, 0x75, 0x36, 0x0d, 0xbd, 0x2b, 0xe7, 0xe6, 0x22, 0x09, 0x2c,
	0xfb, 0x50, 0xa1, 0xa1, 0x86, 0xee, 0x9d, 0xc8, 0xc9, 0xd6, 0xbd, 0x86, 0xfb, 0x3c, 0xcf, 0x09,
	0x95, 0x4a, 0x4b, 0xc2, 0x42, 0xac, 0x8c, 0x41, 0x37, 0xe9, 0xd7, 0xf4, 0xa3, 0x81, 0xec, 0x29,
	0x80, 0x3d, 0x4e, 0xbf, 0xa2, 0x34, 0x7e, 0x7e, 0xd2, 0xb5, 0xe4, 0x3d, 0xca, 0x53, 0x5c, 0x7f,
	0x3a, 0x70, 0xf9, 0x49, 0x93, 0x90, 0x13, 0xb3, 0x47, 0xba, 0x9b, 0xcb, 0x82, 0x0d, 0x20, 0xc0,
	0x15, 0xcf, 0x9a, 0xef, 0x8c, 0xf7, 0xa8, 0x93, 0x80, 0x81, 0x46, 0xc8, 0x9e, 0x41, 0xaf, 0xb6,
	0xb6, 0x1a, 0xb7, 0xd6, 0x04, 0x96, 0xfe, 0x13, 0xa9, 0x45, 0xb1, 0x15, 0x79, 0x8d, 0xc8, 0x52,
	0x2b, 0x1a, 0x40, 0x40, 0x38, 0xc1, 0x46, 0x73, 0xd6, 0x98, 0x19, 0xd8, 0x48, 0xf6, 0x83, 0xf8,
	0x47, 0x41, 0x6e, 0x1f, 0x40, 0xdf, 0x9c, 0xa5, 0x25, 0xd7, 0x1a, 0x49, 0x0e, 0xff, 0xb8, 0x70,
	0x39, 0x42, 0x9e, 0x23, 0xed, 0x26, 0x63, 0x70, 0x26, 0xf9, 0x0c, 0xeb, 0x76, 0x9a, 0xf5, 0x61,
	0x5a, 0xb7, 0x25, 0xed, 0xc1, 0x1d, 0xbd, 0x96, 0x3b, 0xbe, 0x85, 0x80, 0xaa, 0xd9, 0xed, 0xc4,
	0x08, 0x5e, 0x3e, 0x8f, 0xff, 0xf7, 0x90, 0xe2, 0xed, 0x2b, 0x32, 0x85, 0xaa, 0x85, 0x2d, 0x74,
	0x0d, 0xfd, 0x92, 0x50, 0xa1, 0xdc, 0x4b, 0x3b, 0xea, 0x24, 0xbd, 0x1a, 0xb7, 0x0f, 0xe0, 0xfc,
	0x94, 0x01, 0xdc, 0x6b, 0x1f, 0xc0, 0x7e, 0x77, 0x2f, 0x8e, 0xbb, 0x1b, 0xc2, 0xe3, 0xa9, 0xe9,
	0xa5, 0x95, 0xa4, 0xaa, 0xc4, 0x4c, 0x14, 0x02, 0xe9, 0xf6, 0xc9, 0xf7, 0x4d, 0xe4, 0xfc, 0xd8,
	0x44, 0xce, 0xaf, 0x4d, 0xe4, 0x7c, 0xfb, 0x1d, 0x75, 0xbe, 0xf8, 0x7a, 0x5d, 0xa2, 0x1a, 0x9f,
	0x9b, 0x3f, 0xe9, 0xd5, 0xdf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x3c, 0xae, 0x18, 0xc4, 0x57, 0x03,
	0x00, 0x00,
}

func (m *Int64Range) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Int64Range) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Int64Range) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.InvertMatch {
		i--
		if m.InvertMatch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.End != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x10
	}
	if m.Start != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CidrRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CidrRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CidrRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.InvertMatch {
		i--
		if m.InvertMatch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.PrefixLen != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.PrefixLen))
		i--
		dAtA[i] = 0x10
	}
	if len(m.AddressPrefix) > 0 {
		i -= len(m.AddressPrefix)
		copy(dAtA[i:], m.AddressPrefix)
		i = encodeVarintBase(dAtA, i, uint64(len(m.AddressPrefix)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StringMatcherConf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StringMatcherConf) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StringMatcherConf) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.InvertMatch {
		i--
		if m.InvertMatch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.MatchPattern != nil {
		{
			size := m.MatchPattern.Size()
			i -= size
			if _, err := m.MatchPattern.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *StringMatcherConf_ExactMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StringMatcherConf_ExactMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ExactMatch)
	copy(dAtA[i:], m.ExactMatch)
	i = encodeVarintBase(dAtA, i, uint64(len(m.ExactMatch)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}
func (m *StringMatcherConf_PrefixMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StringMatcherConf_PrefixMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.PrefixMatch)
	copy(dAtA[i:], m.PrefixMatch)
	i = encodeVarintBase(dAtA, i, uint64(len(m.PrefixMatch)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *StringMatcherConf_SuffixMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StringMatcherConf_SuffixMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.SuffixMatch)
	copy(dAtA[i:], m.SuffixMatch)
	i = encodeVarintBase(dAtA, i, uint64(len(m.SuffixMatch)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *StringMatcherConf_RegexMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StringMatcherConf_RegexMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.RegexMatch)
	copy(dAtA[i:], m.RegexMatch)
	i = encodeVarintBase(dAtA, i, uint64(len(m.RegexMatch)))
	i--
	dAtA[i] = 0x22
	return len(dAtA) - i, nil
}
func (m *HeaderMatcherConf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeaderMatcherConf) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeaderMatcherConf) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.InvertMatch {
		i--
		if m.InvertMatch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.HeaderMatchSpecifier != nil {
		{
			size := m.HeaderMatchSpecifier.Size()
			i -= size
			if _, err := m.HeaderMatchSpecifier.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintBase(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HeaderMatcherConf_ExactMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeaderMatcherConf_ExactMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ExactMatch)
	copy(dAtA[i:], m.ExactMatch)
	i = encodeVarintBase(dAtA, i, uint64(len(m.ExactMatch)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *HeaderMatcherConf_RegexMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeaderMatcherConf_RegexMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.RegexMatch)
	copy(dAtA[i:], m.RegexMatch)
	i = encodeVarintBase(dAtA, i, uint64(len(m.RegexMatch)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *HeaderMatcherConf_RangeMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeaderMatcherConf_RangeMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RangeMatch != nil {
		{
			size, err := m.RangeMatch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBase(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *HeaderMatcherConf_PresentMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeaderMatcherConf_PresentMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.PresentMatch {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x28
	return len(dAtA) - i, nil
}
func (m *HeaderMatcherConf_PrefixMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeaderMatcherConf_PrefixMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.PrefixMatch)
	copy(dAtA[i:], m.PrefixMatch)
	i = encodeVarintBase(dAtA, i, uint64(len(m.PrefixMatch)))
	i--
	dAtA[i] = 0x32
	return len(dAtA) - i, nil
}
func (m *HeaderMatcherConf_SuffixMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeaderMatcherConf_SuffixMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.SuffixMatch)
	copy(dAtA[i:], m.SuffixMatch)
	i = encodeVarintBase(dAtA, i, uint64(len(m.SuffixMatch)))
	i--
	dAtA[i] = 0x3a
	return len(dAtA) - i, nil
}
func encodeVarintBase(dAtA []byte, offset int, v uint64) int {
	offset -= sovBase(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Int64Range) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Start != 0 {
		n += 1 + sovBase(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovBase(uint64(m.End))
	}
	if m.InvertMatch {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CidrRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AddressPrefix)
	if l > 0 {
		n += 1 + l + sovBase(uint64(l))
	}
	if m.PrefixLen != 0 {
		n += 1 + sovBase(uint64(m.PrefixLen))
	}
	if m.InvertMatch {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StringMatcherConf) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MatchPattern != nil {
		n += m.MatchPattern.Size()
	}
	if m.InvertMatch {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StringMatcherConf_ExactMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ExactMatch)
	n += 1 + l + sovBase(uint64(l))
	return n
}
func (m *StringMatcherConf_PrefixMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PrefixMatch)
	n += 1 + l + sovBase(uint64(l))
	return n
}
func (m *StringMatcherConf_SuffixMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SuffixMatch)
	n += 1 + l + sovBase(uint64(l))
	return n
}
func (m *StringMatcherConf_RegexMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RegexMatch)
	n += 1 + l + sovBase(uint64(l))
	return n
}
func (m *HeaderMatcherConf) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBase(uint64(l))
	}
	if m.HeaderMatchSpecifier != nil {
		n += m.HeaderMatchSpecifier.Size()
	}
	if m.InvertMatch {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HeaderMatcherConf_ExactMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ExactMatch)
	n += 1 + l + sovBase(uint64(l))
	return n
}
func (m *HeaderMatcherConf_RegexMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RegexMatch)
	n += 1 + l + sovBase(uint64(l))
	return n
}
func (m *HeaderMatcherConf_RangeMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RangeMatch != nil {
		l = m.RangeMatch.Size()
		n += 1 + l + sovBase(uint64(l))
	}
	return n
}
func (m *HeaderMatcherConf_PresentMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *HeaderMatcherConf_PrefixMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PrefixMatch)
	n += 1 + l + sovBase(uint64(l))
	return n
}
func (m *HeaderMatcherConf_SuffixMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SuffixMatch)
	n += 1 + l + sovBase(uint64(l))
	return n
}

func sovBase(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozBase(x uint64) (n int) {
	return sovBase(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Int64Range) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Int64Range: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Int64Range: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertMatch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InvertMatch = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CidrRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CidrRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CidrRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBase
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddressPrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixLen", wireType)
			}
			m.PrefixLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrefixLen |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertMatch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InvertMatch = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StringMatcherConf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StringMatcherConf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StringMatcherConf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExactMatch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBase
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchPattern = &StringMatcherConf_ExactMatch{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixMatch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBase
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchPattern = &StringMatcherConf_PrefixMatch{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuffixMatch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBase
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchPattern = &StringMatcherConf_SuffixMatch{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegexMatch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBase
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchPattern = &StringMatcherConf_RegexMatch{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertMatch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InvertMatch = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeaderMatcherConf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeaderMatcherConf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeaderMatcherConf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBase
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExactMatch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBase
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeaderMatchSpecifier = &HeaderMatcherConf_ExactMatch{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegexMatch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBase
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeaderMatchSpecifier = &HeaderMatcherConf_RegexMatch{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeMatch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBase
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Int64Range{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.HeaderMatchSpecifier = &HeaderMatcherConf_RangeMatch{v}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PresentMatch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.HeaderMatchSpecifier = &HeaderMatcherConf_PresentMatch{b}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixMatch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBase
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeaderMatchSpecifier = &HeaderMatcherConf_PrefixMatch{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuffixMatch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBase
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeaderMatchSpecifier = &HeaderMatcherConf_SuffixMatch{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertMatch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InvertMatch = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBase(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBase
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBase
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBase
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBase
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupBase
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthBase
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthBase        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBase          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupBase = fmt.Errorf("proto: unexpected end of group")
)
