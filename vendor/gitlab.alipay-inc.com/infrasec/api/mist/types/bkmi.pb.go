// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: bkmi.proto

package types

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type BKMICommonConfig struct {
	// appname
	AppName string `protobuf:"bytes,1,opt,name=app_name,json=appName,proto3" json:"app_name,omitempty"`
	// mist master flag
	Enable bool `protobuf:"varint,2,opt,name=enable,proto3" json:"enable,omitempty"`
	// version
	Version string `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	// bkmi url, eg. http://bkmi.alipay.com/bkmi/api
	Url string `protobuf:"bytes,4,opt,name=url,proto3" json:"url,omitempty"`
	// use local crypto or crypto plugin
	LocalCrypto bool `protobuf:"varint,5,opt,name=local_crypto,json=localCrypto,proto3" json:"local_crypto,omitempty"`
	// verify the response
	ForceVerify bool `protobuf:"varint,6,opt,name=force_verify,json=forceVerify,proto3" json:"force_verify,omitempty"`
	// default SHA256withRSA_PKCS1
	SignAlg string `protobuf:"bytes,9,opt,name=sign_alg,json=signAlg,proto3" json:"sign_alg,omitempty"`
	// ca root cert
	CaCert []byte `protobuf:"bytes,7,opt,name=ca_cert,json=caCert,proto3" json:"ca_cert,omitempty"`
	// bkmi cert for verify sign
	BkmiCert []byte `protobuf:"bytes,8,opt,name=bkmi_cert,json=bkmiCert,proto3" json:"bkmi_cert,omitempty"`
	// app private key and cert
	Key                  []byte   `protobuf:"bytes,10,opt,name=key,proto3" json:"key,omitempty"`
	Cert                 []byte   `protobuf:"bytes,11,opt,name=cert,proto3" json:"cert,omitempty"`
	SignUrl              string   `protobuf:"bytes,12,opt,name=sign_url,json=signUrl,proto3" json:"sign_url,omitempty"`
	VerifyUrl            string   `protobuf:"bytes,13,opt,name=verify_url,json=verifyUrl,proto3" json:"verify_url,omitempty"`
	DecryptUrl           string   `protobuf:"bytes,14,opt,name=decrypt_url,json=decryptUrl,proto3" json:"decrypt_url,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BKMICommonConfig) Reset()         { *m = BKMICommonConfig{} }
func (m *BKMICommonConfig) String() string { return proto.CompactTextString(m) }
func (*BKMICommonConfig) ProtoMessage()    {}
func (*BKMICommonConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_2faddd50691d71cc, []int{0}
}
func (m *BKMICommonConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BKMICommonConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BKMICommonConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BKMICommonConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BKMICommonConfig.Merge(m, src)
}
func (m *BKMICommonConfig) XXX_Size() int {
	return m.Size()
}
func (m *BKMICommonConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_BKMICommonConfig.DiscardUnknown(m)
}

var xxx_messageInfo_BKMICommonConfig proto.InternalMessageInfo

func (m *BKMICommonConfig) GetAppName() string {
	if m != nil {
		return m.AppName
	}
	return ""
}

func (m *BKMICommonConfig) GetEnable() bool {
	if m != nil {
		return m.Enable
	}
	return false
}

func (m *BKMICommonConfig) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *BKMICommonConfig) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *BKMICommonConfig) GetLocalCrypto() bool {
	if m != nil {
		return m.LocalCrypto
	}
	return false
}

func (m *BKMICommonConfig) GetForceVerify() bool {
	if m != nil {
		return m.ForceVerify
	}
	return false
}

func (m *BKMICommonConfig) GetSignAlg() string {
	if m != nil {
		return m.SignAlg
	}
	return ""
}

func (m *BKMICommonConfig) GetCaCert() []byte {
	if m != nil {
		return m.CaCert
	}
	return nil
}

func (m *BKMICommonConfig) GetBkmiCert() []byte {
	if m != nil {
		return m.BkmiCert
	}
	return nil
}

func (m *BKMICommonConfig) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *BKMICommonConfig) GetCert() []byte {
	if m != nil {
		return m.Cert
	}
	return nil
}

func (m *BKMICommonConfig) GetSignUrl() string {
	if m != nil {
		return m.SignUrl
	}
	return ""
}

func (m *BKMICommonConfig) GetVerifyUrl() string {
	if m != nil {
		return m.VerifyUrl
	}
	return ""
}

func (m *BKMICommonConfig) GetDecryptUrl() string {
	if m != nil {
		return m.DecryptUrl
	}
	return ""
}

func init() {
	proto.RegisterType((*BKMICommonConfig)(nil), "meshapi.security.mist.v1.BKMICommonConfig")
}

func init() { proto.RegisterFile("bkmi.proto", fileDescriptor_2faddd50691d71cc) }

var fileDescriptor_2faddd50691d71cc = []byte{
	// 334 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x44, 0x91, 0x4d, 0x4e, 0xeb, 0x30,
	0x10, 0x80, 0x95, 0x97, 0x36, 0x3f, 0xd3, 0xbe, 0xa7, 0xca, 0x4f, 0x02, 0x23, 0x44, 0x29, 0xac,
	0xba, 0x8a, 0x84, 0x38, 0x01, 0xcd, 0x0a, 0x21, 0x58, 0x54, 0x2a, 0x0b, 0x36, 0x91, 0x1b, 0xa6,
	0xc1, 0xaa, 0x13, 0x5b, 0x8e, 0x5b, 0x29, 0x47, 0xe0, 0x66, 0x2c, 0x39, 0x02, 0xea, 0x49, 0x90,
	0x27, 0x15, 0xec, 0x66, 0xbe, 0x6f, 0xec, 0x99, 0xb1, 0x01, 0xd6, 0xdb, 0x5a, 0x66, 0xc6, 0x6a,
	0xa7, 0x19, 0xaf, 0xb1, 0x7d, 0x13, 0x46, 0x66, 0x2d, 0x96, 0x3b, 0x2b, 0x5d, 0x97, 0xd5, 0xb2,
	0x75, 0xd9, 0xfe, 0xe6, 0xfa, 0x3d, 0x84, 0xc9, 0xe2, 0xe1, 0xf1, 0x3e, 0xd7, 0x75, 0xad, 0x9b,
	0x5c, 0x37, 0x1b, 0x59, 0xb1, 0x33, 0x48, 0x84, 0x31, 0x45, 0x23, 0x6a, 0xe4, 0xc1, 0x2c, 0x98,
	0xa7, 0xcb, 0x58, 0x18, 0xf3, 0x24, 0x6a, 0x64, 0x27, 0x10, 0x61, 0x23, 0xd6, 0x0a, 0xf9, 0x9f,
	0x59, 0x30, 0x4f, 0x96, 0xc7, 0x8c, 0x71, 0x88, 0xf7, 0x68, 0x5b, 0xa9, 0x1b, 0x1e, 0xf6, 0x27,
	0x8e, 0x29, 0x9b, 0x40, 0xb8, 0xb3, 0x8a, 0x0f, 0x88, 0xfa, 0x90, 0x5d, 0xc1, 0x58, 0xe9, 0x52,
	0xa8, 0xa2, 0xb4, 0x9d, 0x71, 0x9a, 0x0f, 0xe9, 0xa6, 0x11, 0xb1, 0x9c, 0x90, 0x2f, 0xd9, 0x68,
	0x5b, 0x62, 0xb1, 0x47, 0x2b, 0x37, 0x1d, 0x8f, 0xfa, 0x12, 0x62, 0xcf, 0x84, 0xfc, 0x90, 0xad,
	0xac, 0x9a, 0x42, 0xa8, 0x8a, 0xa7, 0x7d, 0x4b, 0x9f, 0xdf, 0xa9, 0x8a, 0x9d, 0x42, 0x5c, 0x8a,
	0xa2, 0x44, 0xeb, 0x78, 0x3c, 0x0b, 0xe6, 0xe3, 0x65, 0x54, 0x8a, 0x1c, 0xad, 0x63, 0xe7, 0x90,
	0xfa, 0x57, 0xe9, 0x55, 0x42, 0x2a, 0xf1, 0x80, 0xe4, 0x04, 0xc2, 0x2d, 0x76, 0x1c, 0x08, 0xfb,
	0x90, 0x31, 0x18, 0x50, 0xe5, 0x88, 0x10, 0xc5, 0x3f, 0x6d, 0xfd, 0x4e, 0xe3, 0xdf, 0xb6, 0x2b,
	0xab, 0xd8, 0x05, 0x40, 0x3f, 0x2e, 0xc9, 0xbf, 0x24, 0xd3, 0x9e, 0x78, 0x7d, 0x09, 0xa3, 0x57,
	0xa4, 0x95, 0xc9, 0xff, 0x23, 0x0f, 0x47, 0xb4, 0xb2, 0x6a, 0xf1, 0xff, 0xe3, 0x30, 0x0d, 0x3e,
	0x0f, 0xd3, 0xe0, 0xeb, 0x30, 0x0d, 0x5e, 0x86, 0xae, 0x33, 0xd8, 0xae, 0x23, 0xfa, 0xc1, 0xdb,
	0xef, 0x00, 0x00, 0x00, 0xff, 0xff, 0x7b, 0x0e, 0xd1, 0xe1, 0xcf, 0x01, 0x00, 0x00,
}

func (m *BKMICommonConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BKMICommonConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BKMICommonConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DecryptUrl) > 0 {
		i -= len(m.DecryptUrl)
		copy(dAtA[i:], m.DecryptUrl)
		i = encodeVarintBkmi(dAtA, i, uint64(len(m.DecryptUrl)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.VerifyUrl) > 0 {
		i -= len(m.VerifyUrl)
		copy(dAtA[i:], m.VerifyUrl)
		i = encodeVarintBkmi(dAtA, i, uint64(len(m.VerifyUrl)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.SignUrl) > 0 {
		i -= len(m.SignUrl)
		copy(dAtA[i:], m.SignUrl)
		i = encodeVarintBkmi(dAtA, i, uint64(len(m.SignUrl)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.Cert) > 0 {
		i -= len(m.Cert)
		copy(dAtA[i:], m.Cert)
		i = encodeVarintBkmi(dAtA, i, uint64(len(m.Cert)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintBkmi(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.SignAlg) > 0 {
		i -= len(m.SignAlg)
		copy(dAtA[i:], m.SignAlg)
		i = encodeVarintBkmi(dAtA, i, uint64(len(m.SignAlg)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.BkmiCert) > 0 {
		i -= len(m.BkmiCert)
		copy(dAtA[i:], m.BkmiCert)
		i = encodeVarintBkmi(dAtA, i, uint64(len(m.BkmiCert)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.CaCert) > 0 {
		i -= len(m.CaCert)
		copy(dAtA[i:], m.CaCert)
		i = encodeVarintBkmi(dAtA, i, uint64(len(m.CaCert)))
		i--
		dAtA[i] = 0x3a
	}
	if m.ForceVerify {
		i--
		if m.ForceVerify {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.LocalCrypto {
		i--
		if m.LocalCrypto {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintBkmi(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintBkmi(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Enable {
		i--
		if m.Enable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.AppName) > 0 {
		i -= len(m.AppName)
		copy(dAtA[i:], m.AppName)
		i = encodeVarintBkmi(dAtA, i, uint64(len(m.AppName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintBkmi(dAtA []byte, offset int, v uint64) int {
	offset -= sovBkmi(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *BKMICommonConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AppName)
	if l > 0 {
		n += 1 + l + sovBkmi(uint64(l))
	}
	if m.Enable {
		n += 2
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovBkmi(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovBkmi(uint64(l))
	}
	if m.LocalCrypto {
		n += 2
	}
	if m.ForceVerify {
		n += 2
	}
	l = len(m.CaCert)
	if l > 0 {
		n += 1 + l + sovBkmi(uint64(l))
	}
	l = len(m.BkmiCert)
	if l > 0 {
		n += 1 + l + sovBkmi(uint64(l))
	}
	l = len(m.SignAlg)
	if l > 0 {
		n += 1 + l + sovBkmi(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovBkmi(uint64(l))
	}
	l = len(m.Cert)
	if l > 0 {
		n += 1 + l + sovBkmi(uint64(l))
	}
	l = len(m.SignUrl)
	if l > 0 {
		n += 1 + l + sovBkmi(uint64(l))
	}
	l = len(m.VerifyUrl)
	if l > 0 {
		n += 1 + l + sovBkmi(uint64(l))
	}
	l = len(m.DecryptUrl)
	if l > 0 {
		n += 1 + l + sovBkmi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovBkmi(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozBkmi(x uint64) (n int) {
	return sovBkmi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *BKMICommonConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBkmi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BKMICommonConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BKMICommonConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBkmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBkmi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBkmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBkmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enable = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBkmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBkmi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBkmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBkmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBkmi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBkmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalCrypto", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBkmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LocalCrypto = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceVerify", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBkmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForceVerify = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaCert", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBkmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBkmi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBkmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CaCert = append(m.CaCert[:0], dAtA[iNdEx:postIndex]...)
			if m.CaCert == nil {
				m.CaCert = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BkmiCert", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBkmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBkmi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBkmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BkmiCert = append(m.BkmiCert[:0], dAtA[iNdEx:postIndex]...)
			if m.BkmiCert == nil {
				m.BkmiCert = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignAlg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBkmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBkmi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBkmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignAlg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBkmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBkmi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBkmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cert", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBkmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBkmi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBkmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cert = append(m.Cert[:0], dAtA[iNdEx:postIndex]...)
			if m.Cert == nil {
				m.Cert = []byte{}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBkmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBkmi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBkmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifyUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBkmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBkmi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBkmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VerifyUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecryptUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBkmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBkmi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBkmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DecryptUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBkmi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBkmi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBkmi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBkmi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBkmi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBkmi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBkmi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBkmi
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupBkmi
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthBkmi
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthBkmi        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBkmi          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupBkmi = fmt.Errorf("proto: unexpected end of group")
)
